# 
#

record(bi, "$(P):bGreenInd") {
    field(DESC, "bi record monitoring led 1")
    field(DTYP, "asynInt32")
    field(SCAN, "I/O Intr")
    field(INP,  "@asyn($(PORT) 0 0) BOOL R P=PLC_TC3 V=GVL_EPICS.bGreenInd")
    field(ZNAM, "Zero")
    field(ONAM, "One")
    field(UDFS, "NO_ALARM")
}

record(bi, "$(P):bRedInd") {
    field(DESC, "bi record monitoring led 2")
    field(DTYP, "asynInt32")
    field(SCAN, "I/O Intr")
    field(INP,  "@asyn($(PORT) 0 0) BOOL R P=PLC_TC3 V=GVL_EPICS.bRedInd")
    field(ZNAM, "Zero")
    field(ONAM, "One")
    field(UDFS, "NO_ALARM")
}

record(bo, "$(P):bSwitch1") {
    field(DESC, "bo record controlling switch 1")
    field(DTYP, "asynInt32")
    field(OUT,  "@asyn($(PORT) 0 0) BOOL W P=PLC_TC3 V=GVL_EPICS.bSwitch1")
    field(ZNAM, "Zero")
    field(ONAM, "One")
    field(UDFS, "NO_ALARM")
}

record(bi, "$(P):bSwitch1_RBV") {
    field(DESC, "bi recort controlling switch read back")
    field(DTYP, "asynInt32")
    field(SCAN, "I/O Intr")
    field(INP,  "@asyn($(PORT) 0 0) BOOL R P=PLC_TC3 V=GVL_EPICS.bSwitch1")
    field(ZNAM, "Zero")
    field(ONAM, "One")
    field(UDFS, "NO_ALARM")
    field(FLNK, "$(P):bSwitch1.VAL PP") # Update the longout record with PP (process passive)
}

record(bo, "$(P):bSwitch2") {
    field(DESC, "bo record controlling switch 2")
    field(DTYP, "asynInt32")
    field(OUT,  "@asyn($(PORT) 0 0) BOOL W P=PLC_TC3 V=GVL_EPICS.bSwitch2")
    field(ZNAM, "Zero")
    field(ONAM, "One")
    field(DOL, "$(P):bSwitch2_RBV.VAL PP")
    field(UDFS, "NO_ALARM")
}

record(bi, "$(P):bSwitch2_RBV") {
    field(DESC, "bi recort controlling switch read back")
    field(DTYP, "asynInt32")
    field(SCAN, "I/O Intr")
    field(INP,  "@asyn($(PORT) 0 0) BOOL R P=PLC_TC3 V=GVL_EPICS.bSwitch2")
    field(ZNAM, "Zero")
    field(ONAM, "One")
    field(UDFS, "NO_ALARM")
    field(FLNK, "$(P):bSwitch2.VAL PP") # Update the longout record with PP (process passive)
}

record(ai, "$(P):rTemperatureSensor1") {
    field(DESC, "ai record monitoring temp sensor 1")
    field(PREC, "2")
    field(DTYP, "asynFloat64")
    field(SCAN, "I/O Intr")
    field(INP,  "@asyn($(PORT) 0 0) REAL R P=PLC_TC3 V=GVL_EPICS.rTemperatureSensor1")
    field(UDFS, "NO_ALARM")
}

record(ai, "$(P):rTemperatureSensor2") {
    field(DESC, "ai record monitoring temp sensor 2")
    field(PREC, "2")
    field(DTYP, "asynFloat64")
    field(SCAN, "I/O Intr")
    field(INP,  "@asyn($(PORT) 0 0) REAL R P=PLC_TC3 V=GVL_EPICS.rTemperatureSensor2")
    field(UDFS, "NO_ALARM")
}


#### LINK channels ####

############################################################
### MOVING #### INLINK  TMP: use switch status, will be replace by PLC M1.MOVING
record(bi, "$(P):M1:MOVING") {
    field(DESC, "Moving Status")
    field(DTYP, "asynInt32")
    field(SCAN, "I/O Intr")
    field(INP,  "@asyn($(PORT) 0 0) BOOL R P=PLC_TC3 V=GVL_EPICS.bSwitch2")
#    field(INP, "@asyn($(PORT) 0 0) REAL R P=PLC_TC3 V=M1.MOVING")
    field(ZNAM, "MOVING")
    field(ONAM, "IN POS")
    field(UDFS, "NO_ALARM")
}

############################################################
### VAL #### INLINK  TMP: use temperature as example, will be replace by PLC M1.VAL
record(ai, "$(P):M1:VAL") {
    field(DESC, "Output specification")
    field(DTYP, "asynFloat64")
    field(SCAN, "I/O Intr")
    field(INP, "@asyn($(PORT) 0 0) REAL R P=PLC_TC3 V=GVL_EPICS.rTemperatureSensor2")
#    field(INP, "@asyn($(PORT) 0 0) REAL R P=PLC_TC3 V=M1.VAL")
    field(UDFS, "NO_ALARM")
}

############################################################
### DVAL #### OUTLINK
record(longout, "$(P):M1:DVAL") {
    field(DESC, "Stop Motor")
    field(DTYP, "asynInt32")
    field(OUT,  "@asyn($(PORT) 0 0) DINT W P=PLC_TC3 V=M1.DVAL")
    field(UDFS, "NO_ALARM")
}

############################################################
### RPM #### INLINK  use M1.SPD as example, will be replace by PLC M1.VAL
record(longin, "$(P):M1:RMP") {
    field(DESC, "Raw Motor Position")
    field(DTYP, "asynInt32")
    field(SCAN, "I/O Intr")
    field(INP, "@asyn($(PORT) 0 0) DINT R P=PLC_TC3 V=M1.SPD")
#    field(INP, "@asyn($(PORT) 0 0) DINT R P=PLC_TC3 V=M1.RMP")
    field(UDFS, "NO_ALARM")
}

############################################################
### RDBL #### INLINK  TMP: use temperature as example, will be replace by PLC M1.RDBL
record(ai, "$(P):M1:RDBL") {
    field(DESC, "Output specification")
    field(DTYP, "asynFloat64")
    field(SCAN, "I/O Intr")
    field(INP, "@asyn($(PORT) 0 0) REAL R P=PLC_TC3 V=GVL_EPICS.rTemperatureSensor1")
#    field(INP, "@asyn($(PORT) 0 0) REAL R P=PLC_TC3 V=M1.RDBL")
    field(UDFS, "NO_ALARM")
}

############################################################
### STOP #### OUTLINK TMP: use switch as example, will be replace by PLC M1.STOP
record(bo, "$(P):M1:STOP") {
    field(DESC, "Stop Motor")
    field(DTYP, "asynInt32")
    field(OUT,  "@asyn($(PORT) 0 0) BOOL W P=PLC_TC3 V=GVL_EPICS.bSwitch2")
#    field(OUT,  "@asyn($(PORT) 0 0) BOOL W P=PLC_TC3 V=M1:STOP")
    field(ZNAM, "FREERUN")
    field(ONAM, "STOP")
    field(UDFS, "NO_ALARM")
}


#### NON LINK CHANNEL ####

#############################################################
#### ACCL #### To be replaced by DOUBLE
record(longout, "$(P):M1:ACCL") {
    field(DESC, "Seconds to Velocity")
    field(DTYP, "asynInt32")
    field(OUT, "@asyn($(PORT) 0 0) DINT W P=PLC_TC3 V=M1.ACCL")
    field(OMSL, "supervisory")
    field(UDFS, "NO_ALARM")
}

record(longin, "$(P):M1:ACCL_RBV") {
    field(DESC, "Readback of Seconds to Velocity")
    field(DTYP, "asynInt32")
    field(SCAN, "I/O Intr")
    field(INP, "@asyn($(PORT) 0 0) DINT R P=PLC_TC3 V=M1.ACCL")
    field(UDFS, "NO_ALARM")
    field(FLNK, "$(P):M1:ACCL_FANOUT.PROC") # Process ACCL_SYNC when ACCL_RBV updates
}

record(fanout, "$(P):M1:ACCL_FANOUT") {
    field(DESC, "Fanout for ACCL_RBV Updates")
    field(LNK1, "$(P):M1:ACCL_SYNC.PROC")   # First record to process
    field(LNK2, "$(P):M1:ACCL_SYNC_M.PROC") # Second record to process
    # Add more LNK fields as needed (LNK3, LNK4, etc., up to LNK6)
}

record(calcout, "$(P):M1:ACCL_SYNC") {
    field(DESC, "Sync ACCL_RBV to ACCL")
    field(INPA, "$(P):M1:ACCL_RBV.VAL")
    field(CALC, "A")             # Pass the value of ACCL_RBV directly
    field(OUT, "$(P):M1:ACCL.VAL PP") # Update ACCL without processing its OUT field
    field(SCAN, "Passive")      # Process when ACCL_RBV changes
}

record(calcout, "$(P):M1:ACCL_SYNC_M") {
    field(DESC, "Sync ACCL_RBV to M1.ACCL")
    field(INPA, "$(P):M1:ACCL_RBV.VAL")
    field(CALC, "A")             # Pass the value of ACCL_RBV directly
    field(OUT, "$(P):M1.ACCL PP") # Update .ACCL without processing its OUT field
    field(SCAN, "Passive")      # Process when ACCL_RBV changes
}

#############################################################
#### BACC #### To be replaced by DOUBLE
record(longout, "$(P):M1:BACC") {
    field(DESC, "BL Seconds to Velocity")
    field(DTYP, "asynInt32")
    field(OUT, "@asyn($(PORT) 0 0) DINT W P=PLC_TC3 V=M1.BACC")
    field(OMSL, "supervisory")
    field(UDFS, "NO_ALARM")
}

record(longin, "$(P):M1:BACC_RBV") {
    field(DESC, "Readback of BL Seconds to Velocity")
    field(DTYP, "asynInt32")
    field(SCAN, "I/O Intr")
    field(INP, "@asyn($(PORT) 0 0) DINT R P=PLC_TC3 V=M1.BACC")
    field(UDFS, "NO_ALARM")
    field(FLNK, "$(P):M1:BACC_FANOUT.PROC") # Process BACC_SYNC when BACC_RBV updates
}

record(fanout, "$(P):M1:BACC_FANOUT") {
    field(DESC, "Fanout for BACC_RBV Updates")
    field(LNK1, "$(P):M1:BACC_SYNC.PROC")   # First record to process
    field(LNK2, "$(P):M1:BACC_SYNC_M.PROC") # Second record to process
    # Add more LNK fields as needed (LNK3, LNK4, etc., up to LNK6)
}

record(calcout, "$(P):M1:BACC_SYNC") {
    field(DESC, "Sync BACC_RBV to BACC")
    field(INPA, "$(P):M1:BACC_RBV.VAL")
    field(CALC, "A")             # Pass the value of BACC_RBV directly
    field(OUT, "$(P):M1:BACC.VAL PP") # Update BACC without processing its OUT field
    field(SCAN, "Passive")      # Process when BACC_RBV changes
}

record(calcout, "$(P):M1:BACC_SYNC_M") {
    field(DESC, "Sync BACC_RBV to M1.BACC")
    field(INPA, "$(P):M1:BACC_RBV.VAL")
    field(CALC, "A")             # Pass the value of BACC_RBV directly
    field(OUT, "$(P):M1.BACC PP") # Update .BACC without processing its OUT field
    field(SCAN, "Passive")      # Process when BACC_RBV changes
}


#############################################################
#### BDST #### To be replaced by DOUBLE
record(longout, "$(P):M1:BDST") {
    field(DESC, "BL Distance")
    field(DTYP, "asynInt32")
    field(OUT, "@asyn($(PORT) 0 0) DINT W P=PLC_TC3 V=M1.BDST")
    field(OMSL, "supervisory")
    field(UDFS, "NO_ALARM")
}

record(longin, "$(P):M1:BDST_RBV") {
    field(DESC, "Readback of BL Distance")
    field(DTYP, "asynInt32")
    field(SCAN, "I/O Intr")
    field(INP, "@asyn($(PORT) 0 0) DINT R P=PLC_TC3 V=M1.BDST")
    field(UDFS, "NO_ALARM")
    field(FLNK, "$(P):M1:BDST_FANOUT.PROC") # Process BDST_SYNC when BDST_RBV updates
}

record(fanout, "$(P):M1:BDST_FANOUT") {
    field(DESC, "Fanout for BDST_RBV Updates")
    field(LNK1, "$(P):M1:BDST_SYNC.PROC")   # First record to process
    field(LNK2, "$(P):M1:BDST_SYNC_M.PROC") # Second record to process
    # Add more LNK fields as needed (LNK3, LNK4, etc., up to LNK6)
}

record(calcout, "$(P):M1:BDST_SYNC") {
    field(DESC, "Sync BDST_RBV to BDST")
    field(INPA, "$(P):M1:BDST_RBV.VAL")
    field(CALC, "A")             # Pass the value of BDST_RBV directly
    field(OUT, "$(P):M1:BDST.VAL PP") # Update BDST without processing its OUT field
    field(SCAN, "Passive")      # Process when BDST_RBV changes
}

record(calcout, "$(P):M1:BDST_SYNC_M") {
    field(DESC, "Sync BDST_RBV to M1.BDST")
    field(INPA, "$(P):M1:BDST_RBV.VAL")
    field(CALC, "A")             # Pass the value of BDST_RBV directly
    field(OUT, "$(P):M1.BDST PP") # Update .BDST without processing its OUT field
    field(SCAN, "Passive")      # Process when BDST_RBV changes
}

#############################################################
#### BVEL #### To be replaced by DOUBLE
record(longout, "$(P):M1:BVEL") {
    field(DESC, "BL Distance")
    field(DTYP, "asynInt32")
    field(OUT, "@asyn($(PORT) 0 0) DINT W P=PLC_TC3 V=M1.BVEL")
    field(OMSL, "supervisory")
    field(UDFS, "NO_ALARM")
}

record(longin, "$(P):M1:BVEL_RBV") {
    field(DESC, "Readback of BL Distance")
    field(DTYP, "asynInt32")
    field(SCAN, "I/O Intr")
    field(INP, "@asyn($(PORT) 0 0) DINT R P=PLC_TC3 V=M1.BVEL")
    field(UDFS, "NO_ALARM")
    field(FLNK, "$(P):M1:BVEL_FANOUT.PROC") # Process BVEL_SYNC when BVEL_RBV updates
}

record(fanout, "$(P):M1:BVEL_FANOUT") {
    field(DESC, "Fanout for BVEL_RBV Updates")
    field(LNK1, "$(P):M1:BVEL_SYNC.PROC")   # First record to process
    field(LNK2, "$(P):M1:BVEL_SYNC_M.PROC") # Second record to process
    # Add more LNK fields as needed (LNK3, LNK4, etc., up to LNK6)
}

record(calcout, "$(P):M1:BVEL_SYNC") {
    field(DESC, "Sync BVEL_RBV to BVEL")
    field(INPA, "$(P):M1:BVEL_RBV.VAL")
    field(CALC, "A")             # Pass the value of BVEL_RBV directly
    field(OUT, "$(P):M1:BVEL.VAL PP") # Update BVEL without processing its OUT field
    field(SCAN, "Passive")      # Process when BVEL_RBV changes
}

record(calcout, "$(P):M1:BVEL_SYNC_M") {
    field(DESC, "Sync BVEL_RBV to M1.BVEL")
    field(INPA, "$(P):M1:BVEL_RBV.VAL")
    field(CALC, "A")             # Pass the value of BVEL_RBV directly
    field(OUT, "$(P):M1.BVEL PP") # Update .BVEL without processing its OUT field
    field(SCAN, "Passive")      # Process when BVEL_RBV changes
}

#############################################################
#### CNEN ####
record(longout, "$(P):M1:CNEN") {
    field(DESC, "Enable Device")
    field(DTYP, "asynInt32")
    field(OUT, "@asyn($(PORT) 0 0) INT W P=PLC_TC3 V=M1.CNEN")
    field(OMSL, "supervisory")
    field(UDFS, "NO_ALARM")
}

record(longin, "$(P):M1:CNEN_RBV") {
    field(DESC, "Readback of Enable Device")
    field(DTYP, "asynInt32")
    field(SCAN, "I/O Intr")
    field(INP, "@asyn($(PORT) 0 0) INT R P=PLC_TC3 V=M1.CNEN")
    field(UDFS, "NO_ALARM")
    field(FLNK, "$(P):M1:CNEN_FANOUT.PROC") # Process CNEN_SYNC when CNEN_RBV updates
}

record(fanout, "$(P):M1:CNEN_FANOUT") {
    field(DESC, "Fanout for CNEN_RBV Updates")
    field(LNK1, "$(P):M1:CNEN_SYNC.PROC")   # First record to process
    field(LNK2, "$(P):M1:CNEN_SYNC_M.PROC") # Second record to process
    # Add more LNK fields as needed (LNK3, LNK4, etc., up to LNK6)
}

record(calcout, "$(P):M1:CNEN_SYNC") {
    field(DESC, "Sync CNEN_RBV to CNEN")
    field(INPA, "$(P):M1:CNEN_RBV.VAL")
    field(CALC, "A")             # Pass the value of CNEN_RBV directly
    field(OUT, "$(P):M1:CNEN.VAL PP") # Update CNEN without processing its OUT field
    field(SCAN, "Passive")      # Process when CNEN_RBV changes
}

record(calcout, "$(P):M1:CNEN_SYNC_M") {
    field(DESC, "Sync CNEN_RBV to M1.CNEN")
    field(INPA, "$(P):M1:CNEN_RBV.VAL")
    field(CALC, "A")             # Pass the value of CNEN_RBV directly
    field(OUT, "$(P):M1.CNEN PP") # Update .CNEN without processing its OUT field
    field(SCAN, "Passive")      # Process when CNEN_RBV changes
}

#############################################################
#### EGU ####
record(stringout, "$(P):M1:EGU") {
    field(DESC, "Engineering Unit")
    field(DTYP, "asynOctetWrite")
    field(OUT, "@asyn($(PORT) 0 0) STRING N=2 W P=PLC_TC3 V=M1.EGU")
    field(OMSL, "supervisory")
    field(UDFS, "NO_ALARM")
}

record(stringin, "$(P):M1:EGU_RBV") {
    field(DESC, "Readback of Engineering Unit")
    field(DTYP, "asynOctetRead")
    field(SCAN, "I/O Intr")
    field(INP, "@asyn($(PORT) 0 0) STRING N=2 R P=PLC_TC3 V=M1.EGU")
    field(UDFS, "NO_ALARM")
    field(FLNK, "$(P):M1:EGU_FANOUT.PROC") # Process EGU_SYNC when EGU_RBV updates
}

record(fanout, "$(P):M1:EGU_FANOUT") {
    field(DESC, "Fanout for EGU_RBV Updates")
    field(LNK1, "$(P):M1:EGU_SYNC.PROC")   # First record to process
    field(LNK2, "$(P):M1:EGU_SYNC_M.PROC") # Second record to process
    # Add more LNK fields as needed (LNK3, LNK4, etc., up to LNK6)
}

record(calcout, "$(P):M1:EGU_SYNC") {
    field(DESC, "Sync EGU_RBV to EGU")
    field(INPA, "$(P):M1:EGU_RBV.VAL")
    field(CALC, "A")             # Pass the value of EGU_RBV directly
    field(OUT, "$(P):M1:EGU.VAL PP") # Update EGU without processing its OUT field
    field(SCAN, "Passive")      # Process when EGU_RBV changes
}

record(calcout, "$(P):M1:EGU_SYNC_M") {
    field(DESC, "Sync EGU_RBV to M1.EGU")
    field(INPA, "$(P):M1:EGU_RBV.VAL")
    field(CALC, "A")             # Pass the value of EGU_RBV directly
    field(OUT, "$(P):M1.EGU PP") # Update .EGU without processing its OUT field
    field(SCAN, "Passive")      # Process when EGU_RBV changes
}

#############################################################
#### HOMF ####
record(longout, "$(P):M1:HOMF") {
    field(DESC, "Home Forward")
    field(DTYP, "asynInt32")
    field(OUT, "@asyn($(PORT) 0 0) INT W P=PLC_TC3 V=M1.HOMF")
    field(OMSL, "supervisory")
    field(UDFS, "NO_ALARM")
}

record(longin, "$(P):M1:HOMF_RBV") {
    field(DESC, "Readback of Home Forward")
    field(DTYP, "asynInt32")
    field(SCAN, "I/O Intr")
    field(INP, "@asyn($(PORT) 0 0) INT R P=PLC_TC3 V=M1.HOMF")
    field(UDFS, "NO_ALARM")
    field(FLNK, "$(P):M1:HOMF_FANOUT.PROC") # Process HOMF_SYNC when HOMF_RBV updates
}

record(fanout, "$(P):M1:HOMF_FANOUT") {
    field(DESC, "Fanout for HOMF_RBV Updates")
    field(LNK1, "$(P):M1:HOMF_SYNC.PROC")   # First record to process
    field(LNK2, "$(P):M1:HOMF_SYNC_M.PROC") # Second record to process
    # Add more LNK fields as needed (LNK3, LNK4, etc., up to LNK6)
}

record(calcout, "$(P):M1:HOMF_SYNC") {
    field(DESC, "Sync HOMF_RBV to HOMF")
    field(INPA, "$(P):M1:HOMF_RBV.VAL")
    field(CALC, "A")             # Pass the value of HOMF_RBV directly
    field(OUT, "$(P):M1:HOMF.VAL PP") # Update HOMF without processing its OUT field
    field(SCAN, "Passive")      # Process when HOMF_RBV changes
}

record(calcout, "$(P):M1:HOMF_SYNC_M") {
    field(DESC, "Sync HOMF_RBV to M1.HOMF")
    field(INPA, "$(P):M1:HOMF_RBV.VAL")
    field(CALC, "A")             # Pass the value of HOMF_RBV directly
    field(OUT, "$(P):M1.HOMF PP") # Update .HOMF without processing its OUT field
    field(SCAN, "Passive")      # Process when HOMF_RBV changes
}

#############################################################
#### HOMR ####
record(longout, "$(P):M1:HOMR") {
    field(DESC, "Home Reverse")
    field(DTYP, "asynInt32")
    field(OUT, "@asyn($(PORT) 0 0) INT W P=PLC_TC3 V=M1.HOMR")
    field(OMSL, "supervisory")
    field(UDFS, "NO_ALARM")
}

record(longin, "$(P):M1:HOMR_RBV") {
    field(DESC, "Readback of HOME Reverse")
    field(DTYP, "asynInt32")
    field(SCAN, "I/O Intr")
    field(INP, "@asyn($(PORT) 0 0) INT R P=PLC_TC3 V=M1.HOMR")
    field(UDFS, "NO_ALARM")
    field(FLNK, "$(P):M1:HOMR_FANOUT.PROC") # Process HOMR_SYNC when HOMR_RBV updates
}

record(fanout, "$(P):M1:HOMR_FANOUT") {
    field(DESC, "Fanout for HOMR_RBV Updates")
    field(LNK1, "$(P):M1:HOMR_SYNC.PROC")   # First record to process
    field(LNK2, "$(P):M1:HOMR_SYNC_M.PROC") # Second record to process
    # Add more LNK fields as needed (LNK3, LNK4, etc., up to LNK6)
}

record(calcout, "$(P):M1:HOMR_SYNC") {
    field(DESC, "Sync HOMR_RBV to HOMR")
    field(INPA, "$(P):M1:HOMR_RBV.VAL")
    field(CALC, "A")             # Pass the value of HOMR_RBV directly
    field(OUT, "$(P):M1:HOMR.VAL PP") # Update HOMR without processing its OUT field
    field(SCAN, "Passive")      # Process when HOMR_RBV changes
}

record(calcout, "$(P):M1:HOMR_SYNC_M") {
    field(DESC, "Sync HOMR_RBV to M1.HOMR")
    field(INPA, "$(P):M1:HOMR_RBV.VAL")
    field(CALC, "A")             # Pass the value of HOMR_RBV directly
    field(OUT, "$(P):M1.HOMR PP") # Update .HOMF without processing its OUT field
    field(SCAN, "Passive")      # Process when HOMF_RBV changes
}

#############################################################
#### HVEL #### to be replaced by DOUBLE
record(longout, "$(P):M1:HVEL") {
    field(DESC, "Home Velocity")
    field(DTYP, "asynInt32")
    field(OUT, "@asyn($(PORT) 0 0) DINT W P=PLC_TC3 V=M1.HVEL")
    field(OMSL, "supervisory")
    field(UDFS, "NO_ALARM")
}

record(longin, "$(P):M1:HVEL_RBV") {
    field(DESC, "Readback of Home Velocity")
    field(DTYP, "asynInt32")
    field(SCAN, "I/O Intr")
    field(INP, "@asyn($(PORT) 0 0) DINT R P=PLC_TC3 V=M1.HVEL")
    field(UDFS, "NO_ALARM")
    field(FLNK, "$(P):M1:HVEL_FANOUT.PROC") # Process HVEL_SYNC when HVEL_RBV updates
}

record(fanout, "$(P):M1:HVEL_FANOUT") {
    field(DESC, "Fanout for HVEL_RBV Updates")
    field(LNK1, "$(P):M1:HVEL_SYNC.PROC")   # First record to process
    field(LNK2, "$(P):M1:HVEL_SYNC_M.PROC") # Second record to process
    # Add more LNK fields as needed (LNK3, LNK4, etc., up to LNK6)
}

record(calcout, "$(P):M1:HVEL_SYNC") {
    field(DESC, "Sync HVEL_RBV to HVEL")
    field(INPA, "$(P):M1:HVEL_RBV.VAL")
    field(CALC, "A")             # Pass the value of HVEL_RBV directly
    field(OUT, "$(P):M1:HVEL.VAL PP") # Update HVEL without processing its OUT field
    field(SCAN, "Passive")      # Process when HVEL_RBV changes
}

record(calcout, "$(P):M1:HVEL_SYNC_M") {
    field(DESC, "Sync HVEL_RBV to M1.HVEL")
    field(INPA, "$(P):M1:HVEL_RBV.VAL")
    field(CALC, "A")             # Pass the value of HVEL_RBV directly
    field(OUT, "$(P):M1.HVEL PP") # Update .HOMF without processing its OUT field
    field(SCAN, "Passive")      # Process when HOMF_RBV changes
}

#############################################################
#### JAR #### to be replaced by DOUBLE
record(longout, "$(P):M1:JAR") {
    field(DESC, "Jog Acceleration")
    field(DTYP, "asynInt32")
    field(OUT, "@asyn($(PORT) 0 0) DINT W P=PLC_TC3 V=M1.JAR")
    field(OMSL, "supervisory")
    field(UDFS, "NO_ALARM")
}

record(longin, "$(P):M1:JAR_RBV") {
    field(DESC, "Readback of Jog Acceleration")
    field(DTYP, "asynInt32")
    field(SCAN, "I/O Intr")
    field(INP, "@asyn($(PORT) 0 0) DINT R P=PLC_TC3 V=M1.JAR")
    field(UDFS, "NO_ALARM")
    field(FLNK, "$(P):M1:JAR_FANOUT.PROC") # Process JAR_SYNC when JAR_RBV updates
}

record(fanout, "$(P):M1:JAR_FANOUT") {
    field(DESC, "Fanout for JAR_RBV Updates")
    field(LNK1, "$(P):M1:JAR_SYNC.PROC")   # First record to process
    field(LNK2, "$(P):M1:JAR_SYNC_M.PROC") # Second record to process
    # Add more LNK fields as needed (LNK3, LNK4, etc., up to LNK6)
}

record(calcout, "$(P):M1:JAR_SYNC") {
    field(DESC, "Sync JAR_RBV to JAR")
    field(INPA, "$(P):M1:JAR_RBV.VAL")
    field(CALC, "A")             # Pass the value of JAR_RBV directly
    field(OUT, "$(P):M1:JAR.VAL PP") # Update JAR without processing its OUT field
    field(SCAN, "Passive")      # Process when JAR_RBV changes
}

record(calcout, "$(P):M1:JAR_SYNC_M") {
    field(DESC, "Sync JAR_RBV to M1.JAR")
    field(INPA, "$(P):M1:JAR_RBV.VAL")
    field(CALC, "A")             # Pass the value of JAR_RBV directly
    field(OUT, "$(P):M1.JAR PP") # Update .HOMF without processing its OUT field
    field(SCAN, "Passive")      # Process when HOMF_RBV changes
}

#############################################################
#### JVEL #### to be replaced by DOUBLE
record(longout, "$(P):M1:JVEL") {
    field(DESC, "Jog Velocity")
    field(DTYP, "asynInt32")
    field(OUT, "@asyn($(PORT) 0 0) DINT W P=PLC_TC3 V=M1.JVEL")
    field(OMSL, "supervisory")
    field(UDFS, "NO_ALARM")
}

record(longin, "$(P):M1:JVEL_RBV") {
    field(DESC, "Readback of Jog Velocity")
    field(DTYP, "asynInt32")
    field(SCAN, "I/O Intr")
    field(INP, "@asyn($(PORT) 0 0) DINT R P=PLC_TC3 V=M1.JVEL")
    field(UDFS, "NO_ALARM")
    field(FLNK, "$(P):M1:JVEL_FANOUT.PROC") # Process JVEL_SYNC when JVEL_RBV updates
}

record(fanout, "$(P):M1:JVEL_FANOUT") {
    field(DESC, "Fanout for JVEL_RBV Updates")
    field(LNK1, "$(P):M1:JVEL_SYNC.PROC")   # First record to process
    field(LNK2, "$(P):M1:JVEL_SYNC_M.PROC") # Second record to process
    # Add more LNK fields as needed (LNK3, LNK4, etc., up to LNK6)
}

record(calcout, "$(P):M1:JVEL_SYNC") {
    field(DESC, "Sync JVEL_RBV to JVEL")
    field(INPA, "$(P):M1:JVEL_RBV.VAL")
    field(CALC, "A")             # Pass the value of JVEL_RBV directly
    field(OUT, "$(P):M1:JVEL.VAL PP") # Update JVEL without processing its OUT field
    field(SCAN, "Passive")      # Process when JVEL_RBV changes
}

record(calcout, "$(P):M1:JVEL_SYNC_M") {
    field(DESC, "Sync JVEL_RBV to M1.JVEL")
    field(INPA, "$(P):M1:JVEL_RBV.VAL")
    field(CALC, "A")             # Pass the value of JVEL_RBV directly
    field(OUT, "$(P):M1.JVEL PP") # Update .HOMF without processing its OUT field
    field(SCAN, "Passive")      # Process when HOMF_RBV changes
}

#############################################################
#### S #### to be replaced by DOUBLE
record(longout, "$(P):M1:S") {
    field(DESC, "Jog Velocity")
    field(DTYP, "asynInt32")
    field(OUT, "@asyn($(PORT) 0 0) DINT W P=PLC_TC3 V=M1.SPD")
    field(OMSL, "supervisory")
    field(UDFS, "NO_ALARM")
}

record(longin, "$(P):M1:S_RBV") {
    field(DESC, "Readback of Jog Velocity")
    field(DTYP, "asynInt32")
    field(SCAN, "I/O Intr")
    field(INP, "@asyn($(PORT) 0 0) DINT R P=PLC_TC3 V=M1.SPD")
    field(UDFS, "NO_ALARM")
    field(FLNK, "$(P):M1:S_FANOUT.PROC") # Process S_SYNC when S_RBV updates
}

record(fanout, "$(P):M1:S_FANOUT") {
    field(DESC, "Fanout for S_RBV Updates")
    field(LNK1, "$(P):M1:S_SYNC.PROC")   # First record to process
    field(LNK2, "$(P):M1:S_SYNC_M.PROC") # Second record to process
    # Add more LNK fields as needed (LNK3, LNK4, etc., up to LNK6)
}

record(calcout, "$(P):M1:S_SYNC") {
    field(DESC, "Sync S_RBV to S")
    field(INPA, "$(P):M1:S_RBV.VAL")
    field(CALC, "A")             # Pass the value of S_RBV directly
    field(OUT, "$(P):M1:S.VAL PP") # Update S without processing its OUT field
    field(SCAN, "Passive")      # Process when S_RBV changes
}

record(calcout, "$(P):M1:S_SYNC_M") {
    field(DESC, "Sync S_RBV to M1.S")
    field(INPA, "$(P):M1:S_RBV.VAL")
    field(CALC, "A")             # Pass the value of S_RBV directly
    field(OUT, "$(P):M1.S PP") # Update .HOMF without processing its OUT field
    field(SCAN, "Passive")      # Process when HOMF_RBV changes
}

#############################################################
#### VELO #### to be replaced by DOUBLE
record(longout, "$(P):M1:VELO") {
    field(DESC, "Jog Velocity")
    field(DTYP, "asynInt32")
    field(OUT, "@asyn($(PORT) 0 0) DINT W P=PLC_TC3 V=M1.VELO")
    field(OMSL, "supervisory")
    field(UDFS, "NO_ALARM")
}

record(longin, "$(P):M1:VELO_RBV") {
    field(DESC, "Readback of Jog Velocity")
    field(DTYP, "asynInt32")
    field(SCAN, "I/O Intr")
    field(INP, "@asyn($(PORT) 0 0) DINT R P=PLC_TC3 V=M1.VELO")
    field(UDFS, "NO_ALARM")
    field(FLNK, "$(P):M1:VELO_FANOUT.PROC") # Process VELO_SYNC when VELO_RBV updates
}

record(fanout, "$(P):M1:VELO_FANOUT") {
    field(DESC, "Fanout for VELO_RBV Updates")
    field(LNK1, "$(P):M1:VELO_SYNC.PROC")   # First record to process
    field(LNK2, "$(P):M1:VELO_SYNC_M.PROC") # Second record to process
    # Add more LNK fields as needed (LNK3, LNK4, etc., up to LNK6)
}

record(calcout, "$(P):M1:VELO_SYNC") {
    field(DESC, "Sync VELO_RBV to VELO")
    field(INPA, "$(P):M1:VELO_RBV.VAL")
    field(CALC, "A")             # Pass the value of VELO_RBV directly
    field(OUT, "$(P):M1:VELO.VAL PP") # Update VELO without processing its OUT field
    field(SCAN, "Passive")      # Process when VELO_RBV changes
}

record(calcout, "$(P):M1:VELO_SYNC_M") {
    field(DESC, "Sync VELO_RBV to M1.VELO")
    field(INPA, "$(P):M1:VELO_RBV.VAL")
    field(CALC, "A")             # Pass the value of VELO_RBV directly
    field(OUT, "$(P):M1.VELO PP") # Update .HOMF without processing its OUT field
    field(SCAN, "Passive")      # Process when HOMF_RBV changes
}
#### LINK channels ####

############################################################
### MOVING #### INLINK  TMP: use switch status, will be replace by PLC M2.MOVING
record(bi, "$(P):M2:MOVING") {
    field(DESC, "Moving Status")
    field(DTYP, "asynInt32")
    field(SCAN, "I/O Intr")
    field(INP,  "@asyn($(PORT) 0 0) BOOL R P=PLC_TC3 V=GVL_EPICS.bSwitch2")
#    field(INP, "@asyn($(PORT) 0 0) REAL R P=PLC_TC3 V=M2.MOVING")
    field(ZNAM, "MOVING")
    field(ONAM, "IN POS")
    field(UDFS, "NO_ALARM")
}

############################################################
### VAL #### INLINK  TMP: use temperature as example, will be replace by PLC M2.VAL
record(ai, "$(P):M2:VAL") {
    field(DESC, "Output specification")
    field(DTYP, "asynFloat64")
    field(SCAN, "I/O Intr")
    field(INP, "@asyn($(PORT) 0 0) REAL R P=PLC_TC3 V=GVL_EPICS.rTemperatureSensor2")
#    field(INP, "@asyn($(PORT) 0 0) REAL R P=PLC_TC3 V=M2.VAL")
    field(UDFS, "NO_ALARM")
}

############################################################
### DVAL #### OUTLINK
record(longout, "$(P):M2:DVAL") {
    field(DESC, "Stop Motor")
    field(DTYP, "asynInt32")
    field(OUT,  "@asyn($(PORT) 0 0) DINT W P=PLC_TC3 V=M2.DVAL")
    field(UDFS, "NO_ALARM")
}

############################################################
### RPM #### INLINK  use M2.SPD as example, will be replace by PLC M2.VAL
record(longin, "$(P):M2:RMP") {
    field(DESC, "Raw Motor Position")
    field(DTYP, "asynInt32")
    field(SCAN, "I/O Intr")
    field(INP, "@asyn($(PORT) 0 0) DINT R P=PLC_TC3 V=M2.SPD")
#    field(INP, "@asyn($(PORT) 0 0) DINT R P=PLC_TC3 V=M2.RMP")
    field(UDFS, "NO_ALARM")
}

############################################################
### RDBL #### INLINK  TMP: use temperature as example, will be replace by PLC M2.RDBL
record(ai, "$(P):M2:RDBL") {
    field(DESC, "Output specification")
    field(DTYP, "asynFloat64")
    field(SCAN, "I/O Intr")
    field(INP, "@asyn($(PORT) 0 0) REAL R P=PLC_TC3 V=GVL_EPICS.rTemperatureSensor1")
#    field(INP, "@asyn($(PORT) 0 0) REAL R P=PLC_TC3 V=M2.RDBL")
    field(UDFS, "NO_ALARM")
}

############################################################
### STOP #### OUTLINK TMP: use switch as example, will be replace by PLC M2.STOP
record(bo, "$(P):M2:STOP") {
    field(DESC, "Stop Motor")
    field(DTYP, "asynInt32")
    field(OUT,  "@asyn($(PORT) 0 0) BOOL W P=PLC_TC3 V=GVL_EPICS.bSwitch2")
#    field(OUT,  "@asyn($(PORT) 0 0) BOOL W P=PLC_TC3 V=M2:STOP")
    field(ZNAM, "FREERUN")
    field(ONAM, "STOP")
    field(UDFS, "NO_ALARM")
}


#### NON LINK CHANNEL ####

#############################################################
#### ACCL #### To be replaced by DOUBLE
record(longout, "$(P):M2:ACCL") {
    field(DESC, "Seconds to Velocity")
    field(DTYP, "asynInt32")
    field(OUT, "@asyn($(PORT) 0 0) DINT W P=PLC_TC3 V=M2.ACCL")
    field(OMSL, "supervisory")
    field(UDFS, "NO_ALARM")
}

record(longin, "$(P):M2:ACCL_RBV") {
    field(DESC, "Readback of Seconds to Velocity")
    field(DTYP, "asynInt32")
    field(SCAN, "I/O Intr")
    field(INP, "@asyn($(PORT) 0 0) DINT R P=PLC_TC3 V=M2.ACCL")
    field(UDFS, "NO_ALARM")
    field(FLNK, "$(P):M2:ACCL_FANOUT.PROC") # Process ACCL_SYNC when ACCL_RBV updates
}

record(fanout, "$(P):M2:ACCL_FANOUT") {
    field(DESC, "Fanout for ACCL_RBV Updates")
    field(LNK1, "$(P):M2:ACCL_SYNC.PROC")   # First record to process
    field(LNK2, "$(P):M2:ACCL_SYNC_M.PROC") # Second record to process
    # Add more LNK fields as needed (LNK3, LNK4, etc., up to LNK6)
}

record(calcout, "$(P):M2:ACCL_SYNC") {
    field(DESC, "Sync ACCL_RBV to ACCL")
    field(INPA, "$(P):M2:ACCL_RBV.VAL")
    field(CALC, "A")             # Pass the value of ACCL_RBV directly
    field(OUT, "$(P):M2:ACCL.VAL PP") # Update ACCL without processing its OUT field
    field(SCAN, "Passive")      # Process when ACCL_RBV changes
}

record(calcout, "$(P):M2:ACCL_SYNC_M") {
    field(DESC, "Sync ACCL_RBV to M2.ACCL")
    field(INPA, "$(P):M2:ACCL_RBV.VAL")
    field(CALC, "A")             # Pass the value of ACCL_RBV directly
    field(OUT, "$(P):M2.ACCL PP") # Update .ACCL without processing its OUT field
    field(SCAN, "Passive")      # Process when ACCL_RBV changes
}

#############################################################
#### BACC #### To be replaced by DOUBLE
record(longout, "$(P):M2:BACC") {
    field(DESC, "BL Seconds to Velocity")
    field(DTYP, "asynInt32")
    field(OUT, "@asyn($(PORT) 0 0) DINT W P=PLC_TC3 V=M2.BACC")
    field(OMSL, "supervisory")
    field(UDFS, "NO_ALARM")
}

record(longin, "$(P):M2:BACC_RBV") {
    field(DESC, "Readback of BL Seconds to Velocity")
    field(DTYP, "asynInt32")
    field(SCAN, "I/O Intr")
    field(INP, "@asyn($(PORT) 0 0) DINT R P=PLC_TC3 V=M2.BACC")
    field(UDFS, "NO_ALARM")
    field(FLNK, "$(P):M2:BACC_FANOUT.PROC") # Process BACC_SYNC when BACC_RBV updates
}

record(fanout, "$(P):M2:BACC_FANOUT") {
    field(DESC, "Fanout for BACC_RBV Updates")
    field(LNK1, "$(P):M2:BACC_SYNC.PROC")   # First record to process
    field(LNK2, "$(P):M2:BACC_SYNC_M.PROC") # Second record to process
    # Add more LNK fields as needed (LNK3, LNK4, etc., up to LNK6)
}

record(calcout, "$(P):M2:BACC_SYNC") {
    field(DESC, "Sync BACC_RBV to BACC")
    field(INPA, "$(P):M2:BACC_RBV.VAL")
    field(CALC, "A")             # Pass the value of BACC_RBV directly
    field(OUT, "$(P):M2:BACC.VAL PP") # Update BACC without processing its OUT field
    field(SCAN, "Passive")      # Process when BACC_RBV changes
}

record(calcout, "$(P):M2:BACC_SYNC_M") {
    field(DESC, "Sync BACC_RBV to M2.BACC")
    field(INPA, "$(P):M2:BACC_RBV.VAL")
    field(CALC, "A")             # Pass the value of BACC_RBV directly
    field(OUT, "$(P):M2.BACC PP") # Update .BACC without processing its OUT field
    field(SCAN, "Passive")      # Process when BACC_RBV changes
}


#############################################################
#### BDST #### To be replaced by DOUBLE
record(longout, "$(P):M2:BDST") {
    field(DESC, "BL Distance")
    field(DTYP, "asynInt32")
    field(OUT, "@asyn($(PORT) 0 0) DINT W P=PLC_TC3 V=M2.BDST")
    field(OMSL, "supervisory")
    field(UDFS, "NO_ALARM")
}

record(longin, "$(P):M2:BDST_RBV") {
    field(DESC, "Readback of BL Distance")
    field(DTYP, "asynInt32")
    field(SCAN, "I/O Intr")
    field(INP, "@asyn($(PORT) 0 0) DINT R P=PLC_TC3 V=M2.BDST")
    field(UDFS, "NO_ALARM")
    field(FLNK, "$(P):M2:BDST_FANOUT.PROC") # Process BDST_SYNC when BDST_RBV updates
}

record(fanout, "$(P):M2:BDST_FANOUT") {
    field(DESC, "Fanout for BDST_RBV Updates")
    field(LNK1, "$(P):M2:BDST_SYNC.PROC")   # First record to process
    field(LNK2, "$(P):M2:BDST_SYNC_M.PROC") # Second record to process
    # Add more LNK fields as needed (LNK3, LNK4, etc., up to LNK6)
}

record(calcout, "$(P):M2:BDST_SYNC") {
    field(DESC, "Sync BDST_RBV to BDST")
    field(INPA, "$(P):M2:BDST_RBV.VAL")
    field(CALC, "A")             # Pass the value of BDST_RBV directly
    field(OUT, "$(P):M2:BDST.VAL PP") # Update BDST without processing its OUT field
    field(SCAN, "Passive")      # Process when BDST_RBV changes
}

record(calcout, "$(P):M2:BDST_SYNC_M") {
    field(DESC, "Sync BDST_RBV to M2.BDST")
    field(INPA, "$(P):M2:BDST_RBV.VAL")
    field(CALC, "A")             # Pass the value of BDST_RBV directly
    field(OUT, "$(P):M2.BDST PP") # Update .BDST without processing its OUT field
    field(SCAN, "Passive")      # Process when BDST_RBV changes
}

#############################################################
#### BVEL #### To be replaced by DOUBLE
record(longout, "$(P):M2:BVEL") {
    field(DESC, "BL Distance")
    field(DTYP, "asynInt32")
    field(OUT, "@asyn($(PORT) 0 0) DINT W P=PLC_TC3 V=M2.BVEL")
    field(OMSL, "supervisory")
    field(UDFS, "NO_ALARM")
}

record(longin, "$(P):M2:BVEL_RBV") {
    field(DESC, "Readback of BL Distance")
    field(DTYP, "asynInt32")
    field(SCAN, "I/O Intr")
    field(INP, "@asyn($(PORT) 0 0) DINT R P=PLC_TC3 V=M2.BVEL")
    field(UDFS, "NO_ALARM")
    field(FLNK, "$(P):M2:BVEL_FANOUT.PROC") # Process BVEL_SYNC when BVEL_RBV updates
}

record(fanout, "$(P):M2:BVEL_FANOUT") {
    field(DESC, "Fanout for BVEL_RBV Updates")
    field(LNK1, "$(P):M2:BVEL_SYNC.PROC")   # First record to process
    field(LNK2, "$(P):M2:BVEL_SYNC_M.PROC") # Second record to process
    # Add more LNK fields as needed (LNK3, LNK4, etc., up to LNK6)
}

record(calcout, "$(P):M2:BVEL_SYNC") {
    field(DESC, "Sync BVEL_RBV to BVEL")
    field(INPA, "$(P):M2:BVEL_RBV.VAL")
    field(CALC, "A")             # Pass the value of BVEL_RBV directly
    field(OUT, "$(P):M2:BVEL.VAL PP") # Update BVEL without processing its OUT field
    field(SCAN, "Passive")      # Process when BVEL_RBV changes
}

record(calcout, "$(P):M2:BVEL_SYNC_M") {
    field(DESC, "Sync BVEL_RBV to M2.BVEL")
    field(INPA, "$(P):M2:BVEL_RBV.VAL")
    field(CALC, "A")             # Pass the value of BVEL_RBV directly
    field(OUT, "$(P):M2.BVEL PP") # Update .BVEL without processing its OUT field
    field(SCAN, "Passive")      # Process when BVEL_RBV changes
}

#############################################################
#### CNEN ####
record(longout, "$(P):M2:CNEN") {
    field(DESC, "Enable Device")
    field(DTYP, "asynInt32")
    field(OUT, "@asyn($(PORT) 0 0) INT W P=PLC_TC3 V=M2.CNEN")
    field(OMSL, "supervisory")
    field(UDFS, "NO_ALARM")
}

record(longin, "$(P):M2:CNEN_RBV") {
    field(DESC, "Readback of Enable Device")
    field(DTYP, "asynInt32")
    field(SCAN, "I/O Intr")
    field(INP, "@asyn($(PORT) 0 0) INT R P=PLC_TC3 V=M2.CNEN")
    field(UDFS, "NO_ALARM")
    field(FLNK, "$(P):M2:CNEN_FANOUT.PROC") # Process CNEN_SYNC when CNEN_RBV updates
}

record(fanout, "$(P):M2:CNEN_FANOUT") {
    field(DESC, "Fanout for CNEN_RBV Updates")
    field(LNK1, "$(P):M2:CNEN_SYNC.PROC")   # First record to process
    field(LNK2, "$(P):M2:CNEN_SYNC_M.PROC") # Second record to process
    # Add more LNK fields as needed (LNK3, LNK4, etc., up to LNK6)
}

record(calcout, "$(P):M2:CNEN_SYNC") {
    field(DESC, "Sync CNEN_RBV to CNEN")
    field(INPA, "$(P):M2:CNEN_RBV.VAL")
    field(CALC, "A")             # Pass the value of CNEN_RBV directly
    field(OUT, "$(P):M2:CNEN.VAL PP") # Update CNEN without processing its OUT field
    field(SCAN, "Passive")      # Process when CNEN_RBV changes
}

record(calcout, "$(P):M2:CNEN_SYNC_M") {
    field(DESC, "Sync CNEN_RBV to M2.CNEN")
    field(INPA, "$(P):M2:CNEN_RBV.VAL")
    field(CALC, "A")             # Pass the value of CNEN_RBV directly
    field(OUT, "$(P):M2.CNEN PP") # Update .CNEN without processing its OUT field
    field(SCAN, "Passive")      # Process when CNEN_RBV changes
}

#############################################################
#### EGU ####
record(stringout, "$(P):M2:EGU") {
    field(DESC, "Engineering Unit")
    field(DTYP, "asynOctetWrite")
    field(OUT, "@asyn($(PORT) 0 0) STRING N=2 W P=PLC_TC3 V=M2.EGU")
    field(OMSL, "supervisory")
    field(UDFS, "NO_ALARM")
}

record(stringin, "$(P):M2:EGU_RBV") {
    field(DESC, "Readback of Engineering Unit")
    field(DTYP, "asynOctetRead")
    field(SCAN, "I/O Intr")
    field(INP, "@asyn($(PORT) 0 0) STRING N=2 R P=PLC_TC3 V=M2.EGU")
    field(UDFS, "NO_ALARM")
    field(FLNK, "$(P):M2:EGU_FANOUT.PROC") # Process EGU_SYNC when EGU_RBV updates
}

record(fanout, "$(P):M2:EGU_FANOUT") {
    field(DESC, "Fanout for EGU_RBV Updates")
    field(LNK1, "$(P):M2:EGU_SYNC.PROC")   # First record to process
    field(LNK2, "$(P):M2:EGU_SYNC_M.PROC") # Second record to process
    # Add more LNK fields as needed (LNK3, LNK4, etc., up to LNK6)
}

record(calcout, "$(P):M2:EGU_SYNC") {
    field(DESC, "Sync EGU_RBV to EGU")
    field(INPA, "$(P):M2:EGU_RBV.VAL")
    field(CALC, "A")             # Pass the value of EGU_RBV directly
    field(OUT, "$(P):M2:EGU.VAL PP") # Update EGU without processing its OUT field
    field(SCAN, "Passive")      # Process when EGU_RBV changes
}

record(calcout, "$(P):M2:EGU_SYNC_M") {
    field(DESC, "Sync EGU_RBV to M2.EGU")
    field(INPA, "$(P):M2:EGU_RBV.VAL")
    field(CALC, "A")             # Pass the value of EGU_RBV directly
    field(OUT, "$(P):M2.EGU PP") # Update .EGU without processing its OUT field
    field(SCAN, "Passive")      # Process when EGU_RBV changes
}

#############################################################
#### HOMF ####
record(longout, "$(P):M2:HOMF") {
    field(DESC, "Home Forward")
    field(DTYP, "asynInt32")
    field(OUT, "@asyn($(PORT) 0 0) INT W P=PLC_TC3 V=M2.HOMF")
    field(OMSL, "supervisory")
    field(UDFS, "NO_ALARM")
}

record(longin, "$(P):M2:HOMF_RBV") {
    field(DESC, "Readback of Home Forward")
    field(DTYP, "asynInt32")
    field(SCAN, "I/O Intr")
    field(INP, "@asyn($(PORT) 0 0) INT R P=PLC_TC3 V=M2.HOMF")
    field(UDFS, "NO_ALARM")
    field(FLNK, "$(P):M2:HOMF_FANOUT.PROC") # Process HOMF_SYNC when HOMF_RBV updates
}

record(fanout, "$(P):M2:HOMF_FANOUT") {
    field(DESC, "Fanout for HOMF_RBV Updates")
    field(LNK1, "$(P):M2:HOMF_SYNC.PROC")   # First record to process
    field(LNK2, "$(P):M2:HOMF_SYNC_M.PROC") # Second record to process
    # Add more LNK fields as needed (LNK3, LNK4, etc., up to LNK6)
}

record(calcout, "$(P):M2:HOMF_SYNC") {
    field(DESC, "Sync HOMF_RBV to HOMF")
    field(INPA, "$(P):M2:HOMF_RBV.VAL")
    field(CALC, "A")             # Pass the value of HOMF_RBV directly
    field(OUT, "$(P):M2:HOMF.VAL PP") # Update HOMF without processing its OUT field
    field(SCAN, "Passive")      # Process when HOMF_RBV changes
}

record(calcout, "$(P):M2:HOMF_SYNC_M") {
    field(DESC, "Sync HOMF_RBV to M2.HOMF")
    field(INPA, "$(P):M2:HOMF_RBV.VAL")
    field(CALC, "A")             # Pass the value of HOMF_RBV directly
    field(OUT, "$(P):M2.HOMF PP") # Update .HOMF without processing its OUT field
    field(SCAN, "Passive")      # Process when HOMF_RBV changes
}

#############################################################
#### HOMR ####
record(longout, "$(P):M2:HOMR") {
    field(DESC, "Home Reverse")
    field(DTYP, "asynInt32")
    field(OUT, "@asyn($(PORT) 0 0) INT W P=PLC_TC3 V=M2.HOMR")
    field(OMSL, "supervisory")
    field(UDFS, "NO_ALARM")
}

record(longin, "$(P):M2:HOMR_RBV") {
    field(DESC, "Readback of HOME Reverse")
    field(DTYP, "asynInt32")
    field(SCAN, "I/O Intr")
    field(INP, "@asyn($(PORT) 0 0) INT R P=PLC_TC3 V=M2.HOMR")
    field(UDFS, "NO_ALARM")
    field(FLNK, "$(P):M2:HOMR_FANOUT.PROC") # Process HOMR_SYNC when HOMR_RBV updates
}

record(fanout, "$(P):M2:HOMR_FANOUT") {
    field(DESC, "Fanout for HOMR_RBV Updates")
    field(LNK1, "$(P):M2:HOMR_SYNC.PROC")   # First record to process
    field(LNK2, "$(P):M2:HOMR_SYNC_M.PROC") # Second record to process
    # Add more LNK fields as needed (LNK3, LNK4, etc., up to LNK6)
}

record(calcout, "$(P):M2:HOMR_SYNC") {
    field(DESC, "Sync HOMR_RBV to HOMR")
    field(INPA, "$(P):M2:HOMR_RBV.VAL")
    field(CALC, "A")             # Pass the value of HOMR_RBV directly
    field(OUT, "$(P):M2:HOMR.VAL PP") # Update HOMR without processing its OUT field
    field(SCAN, "Passive")      # Process when HOMR_RBV changes
}

record(calcout, "$(P):M2:HOMR_SYNC_M") {
    field(DESC, "Sync HOMR_RBV to M2.HOMR")
    field(INPA, "$(P):M2:HOMR_RBV.VAL")
    field(CALC, "A")             # Pass the value of HOMR_RBV directly
    field(OUT, "$(P):M2.HOMR PP") # Update .HOMF without processing its OUT field
    field(SCAN, "Passive")      # Process when HOMF_RBV changes
}

#############################################################
#### HVEL #### to be replaced by DOUBLE
record(longout, "$(P):M2:HVEL") {
    field(DESC, "Home Velocity")
    field(DTYP, "asynInt32")
    field(OUT, "@asyn($(PORT) 0 0) DINT W P=PLC_TC3 V=M2.HVEL")
    field(OMSL, "supervisory")
    field(UDFS, "NO_ALARM")
}

record(longin, "$(P):M2:HVEL_RBV") {
    field(DESC, "Readback of Home Velocity")
    field(DTYP, "asynInt32")
    field(SCAN, "I/O Intr")
    field(INP, "@asyn($(PORT) 0 0) DINT R P=PLC_TC3 V=M2.HVEL")
    field(UDFS, "NO_ALARM")
    field(FLNK, "$(P):M2:HVEL_FANOUT.PROC") # Process HVEL_SYNC when HVEL_RBV updates
}

record(fanout, "$(P):M2:HVEL_FANOUT") {
    field(DESC, "Fanout for HVEL_RBV Updates")
    field(LNK1, "$(P):M2:HVEL_SYNC.PROC")   # First record to process
    field(LNK2, "$(P):M2:HVEL_SYNC_M.PROC") # Second record to process
    # Add more LNK fields as needed (LNK3, LNK4, etc., up to LNK6)
}

record(calcout, "$(P):M2:HVEL_SYNC") {
    field(DESC, "Sync HVEL_RBV to HVEL")
    field(INPA, "$(P):M2:HVEL_RBV.VAL")
    field(CALC, "A")             # Pass the value of HVEL_RBV directly
    field(OUT, "$(P):M2:HVEL.VAL PP") # Update HVEL without processing its OUT field
    field(SCAN, "Passive")      # Process when HVEL_RBV changes
}

record(calcout, "$(P):M2:HVEL_SYNC_M") {
    field(DESC, "Sync HVEL_RBV to M2.HVEL")
    field(INPA, "$(P):M2:HVEL_RBV.VAL")
    field(CALC, "A")             # Pass the value of HVEL_RBV directly
    field(OUT, "$(P):M2.HVEL PP") # Update .HOMF without processing its OUT field
    field(SCAN, "Passive")      # Process when HOMF_RBV changes
}

#############################################################
#### JAR #### to be replaced by DOUBLE
record(longout, "$(P):M2:JAR") {
    field(DESC, "Jog Acceleration")
    field(DTYP, "asynInt32")
    field(OUT, "@asyn($(PORT) 0 0) DINT W P=PLC_TC3 V=M2.JAR")
    field(OMSL, "supervisory")
    field(UDFS, "NO_ALARM")
}

record(longin, "$(P):M2:JAR_RBV") {
    field(DESC, "Readback of Jog Acceleration")
    field(DTYP, "asynInt32")
    field(SCAN, "I/O Intr")
    field(INP, "@asyn($(PORT) 0 0) DINT R P=PLC_TC3 V=M2.JAR")
    field(UDFS, "NO_ALARM")
    field(FLNK, "$(P):M2:JAR_FANOUT.PROC") # Process JAR_SYNC when JAR_RBV updates
}

record(fanout, "$(P):M2:JAR_FANOUT") {
    field(DESC, "Fanout for JAR_RBV Updates")
    field(LNK1, "$(P):M2:JAR_SYNC.PROC")   # First record to process
    field(LNK2, "$(P):M2:JAR_SYNC_M.PROC") # Second record to process
    # Add more LNK fields as needed (LNK3, LNK4, etc., up to LNK6)
}

record(calcout, "$(P):M2:JAR_SYNC") {
    field(DESC, "Sync JAR_RBV to JAR")
    field(INPA, "$(P):M2:JAR_RBV.VAL")
    field(CALC, "A")             # Pass the value of JAR_RBV directly
    field(OUT, "$(P):M2:JAR.VAL PP") # Update JAR without processing its OUT field
    field(SCAN, "Passive")      # Process when JAR_RBV changes
}

record(calcout, "$(P):M2:JAR_SYNC_M") {
    field(DESC, "Sync JAR_RBV to M2.JAR")
    field(INPA, "$(P):M2:JAR_RBV.VAL")
    field(CALC, "A")             # Pass the value of JAR_RBV directly
    field(OUT, "$(P):M2.JAR PP") # Update .HOMF without processing its OUT field
    field(SCAN, "Passive")      # Process when HOMF_RBV changes
}

#############################################################
#### JVEL #### to be replaced by DOUBLE
record(longout, "$(P):M2:JVEL") {
    field(DESC, "Jog Velocity")
    field(DTYP, "asynInt32")
    field(OUT, "@asyn($(PORT) 0 0) DINT W P=PLC_TC3 V=M2.JVEL")
    field(OMSL, "supervisory")
    field(UDFS, "NO_ALARM")
}

record(longin, "$(P):M2:JVEL_RBV") {
    field(DESC, "Readback of Jog Velocity")
    field(DTYP, "asynInt32")
    field(SCAN, "I/O Intr")
    field(INP, "@asyn($(PORT) 0 0) DINT R P=PLC_TC3 V=M2.JVEL")
    field(UDFS, "NO_ALARM")
    field(FLNK, "$(P):M2:JVEL_FANOUT.PROC") # Process JVEL_SYNC when JVEL_RBV updates
}

record(fanout, "$(P):M2:JVEL_FANOUT") {
    field(DESC, "Fanout for JVEL_RBV Updates")
    field(LNK1, "$(P):M2:JVEL_SYNC.PROC")   # First record to process
    field(LNK2, "$(P):M2:JVEL_SYNC_M.PROC") # Second record to process
    # Add more LNK fields as needed (LNK3, LNK4, etc., up to LNK6)
}

record(calcout, "$(P):M2:JVEL_SYNC") {
    field(DESC, "Sync JVEL_RBV to JVEL")
    field(INPA, "$(P):M2:JVEL_RBV.VAL")
    field(CALC, "A")             # Pass the value of JVEL_RBV directly
    field(OUT, "$(P):M2:JVEL.VAL PP") # Update JVEL without processing its OUT field
    field(SCAN, "Passive")      # Process when JVEL_RBV changes
}

record(calcout, "$(P):M2:JVEL_SYNC_M") {
    field(DESC, "Sync JVEL_RBV to M2.JVEL")
    field(INPA, "$(P):M2:JVEL_RBV.VAL")
    field(CALC, "A")             # Pass the value of JVEL_RBV directly
    field(OUT, "$(P):M2.JVEL PP") # Update .HOMF without processing its OUT field
    field(SCAN, "Passive")      # Process when HOMF_RBV changes
}

#############################################################
#### S #### to be replaced by DOUBLE
record(longout, "$(P):M2:S") {
    field(DESC, "Jog Velocity")
    field(DTYP, "asynInt32")
    field(OUT, "@asyn($(PORT) 0 0) DINT W P=PLC_TC3 V=M2.SPD")
    field(OMSL, "supervisory")
    field(UDFS, "NO_ALARM")
}

record(longin, "$(P):M2:S_RBV") {
    field(DESC, "Readback of Jog Velocity")
    field(DTYP, "asynInt32")
    field(SCAN, "I/O Intr")
    field(INP, "@asyn($(PORT) 0 0) DINT R P=PLC_TC3 V=M2.SPD")
    field(UDFS, "NO_ALARM")
    field(FLNK, "$(P):M2:S_FANOUT.PROC") # Process S_SYNC when S_RBV updates
}

record(fanout, "$(P):M2:S_FANOUT") {
    field(DESC, "Fanout for S_RBV Updates")
    field(LNK1, "$(P):M2:S_SYNC.PROC")   # First record to process
    field(LNK2, "$(P):M2:S_SYNC_M.PROC") # Second record to process
    # Add more LNK fields as needed (LNK3, LNK4, etc., up to LNK6)
}

record(calcout, "$(P):M2:S_SYNC") {
    field(DESC, "Sync S_RBV to S")
    field(INPA, "$(P):M2:S_RBV.VAL")
    field(CALC, "A")             # Pass the value of S_RBV directly
    field(OUT, "$(P):M2:S.VAL PP") # Update S without processing its OUT field
    field(SCAN, "Passive")      # Process when S_RBV changes
}

record(calcout, "$(P):M2:S_SYNC_M") {
    field(DESC, "Sync S_RBV to M2.S")
    field(INPA, "$(P):M2:S_RBV.VAL")
    field(CALC, "A")             # Pass the value of S_RBV directly
    field(OUT, "$(P):M2.S PP") # Update .HOMF without processing its OUT field
    field(SCAN, "Passive")      # Process when HOMF_RBV changes
}

#############################################################
#### VELO #### to be replaced by DOUBLE
record(longout, "$(P):M2:VELO") {
    field(DESC, "Jog Velocity")
    field(DTYP, "asynInt32")
    field(OUT, "@asyn($(PORT) 0 0) DINT W P=PLC_TC3 V=M2.VELO")
    field(OMSL, "supervisory")
    field(UDFS, "NO_ALARM")
}

record(longin, "$(P):M2:VELO_RBV") {
    field(DESC, "Readback of Jog Velocity")
    field(DTYP, "asynInt32")
    field(SCAN, "I/O Intr")
    field(INP, "@asyn($(PORT) 0 0) DINT R P=PLC_TC3 V=M2.VELO")
    field(UDFS, "NO_ALARM")
    field(FLNK, "$(P):M2:VELO_FANOUT.PROC") # Process VELO_SYNC when VELO_RBV updates
}

record(fanout, "$(P):M2:VELO_FANOUT") {
    field(DESC, "Fanout for VELO_RBV Updates")
    field(LNK1, "$(P):M2:VELO_SYNC.PROC")   # First record to process
    field(LNK2, "$(P):M2:VELO_SYNC_M.PROC") # Second record to process
    # Add more LNK fields as needed (LNK3, LNK4, etc., up to LNK6)
}

record(calcout, "$(P):M2:VELO_SYNC") {
    field(DESC, "Sync VELO_RBV to VELO")
    field(INPA, "$(P):M2:VELO_RBV.VAL")
    field(CALC, "A")             # Pass the value of VELO_RBV directly
    field(OUT, "$(P):M2:VELO.VAL PP") # Update VELO without processing its OUT field
    field(SCAN, "Passive")      # Process when VELO_RBV changes
}

record(calcout, "$(P):M2:VELO_SYNC_M") {
    field(DESC, "Sync VELO_RBV to M2.VELO")
    field(INPA, "$(P):M2:VELO_RBV.VAL")
    field(CALC, "A")             # Pass the value of VELO_RBV directly
    field(OUT, "$(P):M2.VELO PP") # Update .HOMF without processing its OUT field
    field(SCAN, "Passive")      # Process when HOMF_RBV changes
}

record(motor, "$(P):M1") {
    field(DTYP, "Soft Channel")         # Soft Channel Motor
    field(DINP,  "$(P):M1:MOVING")    # Motor Moving 
#    field(DOL,  "$(P):M1:VAL")        # Desired Outplut Loc 
##    field(OMLS,  "$(P):M1:")          #  
    field(OUT,  "$(P):M1:DVAL PP MS")       # Set motor position EGU
#    field(RDBL,  "$(P):M1:RDBL")      # Readback Location 
    field(RINP,  "$(P):M1:RMP")        # Raw Motor Position
##    field(RLINK,  "$(P):M1:")          #  
    field(STOO,  "$(P):M1:STOP.VAL NPP MS")      # Stop Motor 
}

